{"version":3,"sources":["webpack:///index.min.js","webpack:///webpack/bootstrap cabe18bbe09b5dd33cbc","webpack:///./src/index.js","webpack:///./~/process/browser.js","webpack:///external \"whatwg-fetch\""],"names":["module","exports","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","process","global","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","attach","env","fetch","err","Error","_len","arguments","args","_key","interceptor","concat","_len2","_key2","reversedInterceptors","interceptors","reduce","array","promise","Promise","resolve","forEach","_ref","request","requestError","then","_ref2","response","responseError","_response","Object","assign","_responseError","_typeof","Symbol","iterator","obj","constructor","prototype","ENVIRONMENT_IS_REACT_NATIVE","navigator","product","ENVIRONMENT_IS_NODE","ENVIRONMENT_IS_WEB","window","ENVIRONMENT_IS_WORKER","importScripts","self","register","push","index","indexOf","splice","clear","this","defaultSetTimout","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","e","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","len","run","Item","noop","nextTick","apply","title","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","require"],"mappings":"AAAAA,OAAOC,QACE,SAAUC,GCGnB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAH,OAGA,IAAAD,GAAAK,EAAAD,IACAH,WACAK,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAR,EAAAC,QAAAD,IAAAC,QAAAE,GAGAH,EAAAO,QAAA,EAGAP,EAAAC,QAvBA,GAAAI,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDOM,SAAUH,EAAQC,EAASE,IAEJ,SAASS,EAASC,GAAS,YAIvD,SAASC,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIG,GAAI,EAAGC,EAAOH,MAAMD,EAAIK,QAASF,EAAIH,EAAIK,OAAQF,IAAOC,EAAKD,GAAKH,EAAIG,EAAM,OAAOC,GAAe,MAAOH,OAAMK,KAAKN,GE3B3L,QAASO,GAAOC,GAEd,IAAKA,EAAIC,MACP,IACErB,EAAQ,GACR,MAAOsB,GACP,KAAMC,OAAM,0DAGhBH,EAAIC,MAAS,SAAUA,GACrB,MAAO,YAAmB,OAAAG,GAAAC,UAAAR,OAANS,EAAMb,MAAAW,GAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAND,EAAMC,GAAAF,UAAAE,EACxB,OAAOC,iBAAYP,GAAZQ,OAAsBH,MAE9BN,EAAIC,OAKT,QAASO,GAAYP,GAAgB,OAAAS,GAAAL,UAAAR,OAANS,EAAMb,MAAAiB,EAAA,EAAAA,EAAA,KAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAANL,EAAMK,EAAA,GAAAN,UAAAM,EACnC,IAAMC,GAAuBC,EAAaC,OAAO,SAACC,EAAOP,GAAR,OAAyBA,GAAaC,OAAOM,QAC1FC,EAAUC,QAAQC,QAAQZ,EAsB9B,OAnBAM,GAAqBO,QAAQ,SAAAC,GAA+B,GAA5BC,GAA4BD,EAA5BC,QAASC,EAAmBF,EAAnBE,cACnCD,GAAWC,KACbN,EAAUA,EAAQO,KAAK,SAAAjB,GAAA,MAAQe,kBAAWf,KAAO,SAAAA,GAAA,MAAQgB,kBAAgBhB,SAK7EU,EAAUA,EAAQO,KAAK,SAAAjB,GAAA,MAAQL,kBAASK,MAGxCM,EAAqBO,QAAQ,SAAAK,GAAiC,GAA9BC,GAA8BD,EAA9BC,SAAUC,EAAoBF,EAApBE,eACpCD,GAAYC,KACdV,EAAUA,EAAQO,KAChB,SAACI,GAAD,MAAeF,GAASE,EAAWC,OAAOC,UAAWvB,EAAK,MAC1D,SAACwB,GAAD,MAAoBJ,GAAcI,EAAgBF,OAAOC,UAAWvB,EAAK,UAKxEU,EFjBR,GAAIe,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAOI,UAAY,eAAkBF,IE1CjQG,EAAmD,YAArB,mBAAOC,WAAP,YAAAP,EAAOO,aAAgD,gBAAtBA,UAAUC,QACzEC,EAAyC,YAAnB,mBAAOnD,GAAP,YAAA0C,EAAO1C,MAAwB,EACrDoD,EAAuC,YAAlB,mBAAOC,QAAP,YAAAX,EAAOW,SAC5BC,EAAiD,kBAAlBC,cAErC,IAAIP,EACFtC,EAAOT,OACF,IAAIqD,EACT5C,EAAO8C,UACF,IAAIJ,EACT1C,EAAO2C,YACF,KAAIF,EAGT,KAAM,IAAIrC,OAAM,8CAFhBJ,GAAOT,GAqBT,GAAIuB,KA6BJpC,GAAOC,SACLoE,SAAU,SAAUtC,GAElB,MADAK,GAAakC,KAAKvC,GACX,WACL,GAAMwC,GAAQnC,EAAaoC,QAAQzC,EAC/BwC,IAAS,GACXnC,EAAaqC,OAAOF,EAAO,KAIjCG,MAAO,WACLtC,SF8E0B5B,KAAKP,EAASE,EAAoB,GAAK,WAAa,MAAOwE,WAInF,SAAU3E,EAAQC,GAEvB,YGzJD,SAAS2E,KACL,KAAM,IAAIlD,OAAM,mCAEpB,QAASmD,KACL,KAAM,IAAInD,OAAM,qCAsBpB,QAASoD,GAAWC,GAChB,GAAIC,IAAqBC,WAErB,MAAOA,YAAWF,EAAK,EAG3B,KAAKC,IAAqBJ,IAAqBI,IAAqBC,WAEhE,MADAD,GAAmBC,WACZA,WAAWF,EAAK,EAE3B,KAEI,MAAOC,GAAiBD,EAAK,GAC/B,MAAMG,GACJ,IAEI,MAAOF,GAAiBxE,KAAK,KAAMuE,EAAK,GAC1C,MAAMG,GAEJ,MAAOF,GAAiBxE,KAAKmE,KAAMI,EAAK,KAMpD,QAASI,GAAgBC,GACrB,GAAIC,IAAuBC,aAEvB,MAAOA,cAAaF,EAGxB,KAAKC,IAAuBR,IAAwBQ,IAAuBC,aAEvE,MADAD,GAAqBC,aACdA,aAAaF,EAExB,KAEI,MAAOC,GAAmBD,GAC5B,MAAOF,GACL,IAEI,MAAOG,GAAmB7E,KAAK,KAAM4E,GACvC,MAAOF,GAGL,MAAOG,GAAmB7E,KAAKmE,KAAMS,KAYjD,QAASG,KACAC,GAAaC,IAGlBD,GAAW,EACPC,EAAarE,OACbsE,EAAQD,EAAazD,OAAO0D,GAE5BC,GAAa,EAEbD,EAAMtE,QACNwE,KAIR,QAASA,KACL,IAAIJ,EAAJ,CAGA,GAAIK,GAAUf,EAAWS,EACzBC,IAAW,CAGX,KADA,GAAIM,GAAMJ,EAAMtE,OACV0E,GAAK,CAGP,IAFAL,EAAeC,EACfA,OACSC,EAAaG,GACdL,GACAA,EAAaE,GAAYI,KAGjCJ,IAAa,EACbG,EAAMJ,EAAMtE,OAEhBqE,EAAe,KACfD,GAAW,EACXL,EAAgBU,IAiBpB,QAASG,GAAKjB,EAAKzC,GACfqC,KAAKI,IAAMA,EACXJ,KAAKrC,MAAQA,EAYjB,QAAS2D,MAhKT,GAOIjB,GACAK,EARAzE,EAAUZ,EAAOC,YAgBpB,WACG,IAEQ+E,EADsB,kBAAfC,YACYA,WAEAL,EAEzB,MAAOM,GACLF,EAAmBJ,EAEvB,IAEQS,EADwB,kBAAjBC,cACcA,aAEAT,EAE3B,MAAOK,GACLG,EAAqBR,KAuD7B,IAEIY,GAFAC,KACAF,GAAW,EAEXG,GAAa,CAyCjB/E,GAAQsF,SAAW,SAAUnB,GACzB,GAAIlD,GAAO,GAAIb,OAAMY,UAAUR,OAAS,EACxC,IAAIQ,UAAUR,OAAS,EACnB,IAAK,GAAIF,GAAI,EAAGA,EAAIU,UAAUR,OAAQF,IAClCW,EAAKX,EAAI,GAAKU,UAAUV,EAGhCwE,GAAMpB,KAAK,GAAI0B,GAAKjB,EAAKlD,IACJ,IAAjB6D,EAAMtE,QAAiBoE,GACvBV,EAAWc,IASnBI,EAAKrC,UAAUoC,IAAM,WACjBpB,KAAKI,IAAIoB,MAAM,KAAMxB,KAAKrC,QAE9B1B,EAAQwF,MAAQ,UAChBxF,EAAQyF,SAAU,EAClBzF,EAAQW,OACRX,EAAQ0F,QACR1F,EAAQ2F,QAAU,GAClB3F,EAAQ4F,YAIR5F,EAAQ6F,GAAKR,EACbrF,EAAQ8F,YAAcT,EACtBrF,EAAQ+F,KAAOV,EACfrF,EAAQgG,IAAMX,EACdrF,EAAQiG,eAAiBZ,EACzBrF,EAAQkG,mBAAqBb,EAC7BrF,EAAQmG,KAAOd,EACfrF,EAAQoG,gBAAkBf,EAC1BrF,EAAQqG,oBAAsBhB,EAE9BrF,EAAQsG,UAAY,SAAUC,GAAQ,UAEtCvG,EAAQwG,QAAU,SAAUD,GACxB,KAAM,IAAIzF,OAAM,qCAGpBd,EAAQyG,IAAM,WAAc,MAAO,KACnCzG,EAAQ0G,MAAQ,SAAUC,GACtB,KAAM,IAAI7F,OAAM,mCAEpBd,EAAQ4G,MAAQ,WAAa,MAAO,KH2K9B,SAAUxH,EAAQC,GIlWxBD,EAAAC,QAAAwH,QAAA","file":"index.min.js","sourcesContent":["module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\t/*\n\t* Configuration for React-Native's package system\n\t* @providesModule whatwg-fetch\n\t*/\n\t\n\t// Uses Emscripten stategy for determining environment\n\tvar ENVIRONMENT_IS_REACT_NATIVE = (typeof navigator === 'undefined' ? 'undefined' : _typeof(navigator)) === 'object' && navigator.product === 'ReactNative';\n\tvar ENVIRONMENT_IS_NODE = (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === 'object' && \"function\" === 'function';\n\tvar ENVIRONMENT_IS_WEB = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object';\n\tvar ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n\t\n\tif (ENVIRONMENT_IS_REACT_NATIVE) {\n\t  attach(global);\n\t} else if (ENVIRONMENT_IS_WORKER) {\n\t  attach(self);\n\t} else if (ENVIRONMENT_IS_WEB) {\n\t  attach(window);\n\t} else if (ENVIRONMENT_IS_NODE) {\n\t  attach(global);\n\t} else {\n\t  throw new Error('Unsupported environment for fetch-intercept');\n\t}\n\t\n\tfunction attach(env) {\n\t  // Make sure fetch is available in the given environment\n\t  if (!env.fetch) {\n\t    try {\n\t      __webpack_require__(2);\n\t    } catch (err) {\n\t      throw Error('No fetch available. Unable to register fetch-intercept');\n\t    }\n\t  }\n\t  env.fetch = function (fetch) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      return interceptor.apply(undefined, [fetch].concat(args));\n\t    };\n\t  }(env.fetch);\n\t}\n\t\n\tvar interceptors = [];\n\t\n\tfunction interceptor(fetch) {\n\t  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t    args[_key2 - 1] = arguments[_key2];\n\t  }\n\t\n\t  var reversedInterceptors = interceptors.reduce(function (array, interceptor) {\n\t    return [interceptor].concat(array);\n\t  }, []);\n\t  var promise = Promise.resolve(args);\n\t\n\t  // Register request interceptors\n\t  reversedInterceptors.forEach(function (_ref) {\n\t    var request = _ref.request,\n\t        requestError = _ref.requestError;\n\t\n\t    if (request || requestError) {\n\t      promise = promise.then(function (args) {\n\t        return request.apply(undefined, _toConsumableArray(args));\n\t      }, function (args) {\n\t        return requestError.apply(undefined, _toConsumableArray(args));\n\t      });\n\t    }\n\t  });\n\t\n\t  // Register fetch call\n\t  promise = promise.then(function (args) {\n\t    return fetch.apply(undefined, _toConsumableArray(args));\n\t  });\n\t\n\t  // Register response interceptors\n\t  reversedInterceptors.forEach(function (_ref2) {\n\t    var response = _ref2.response,\n\t        responseError = _ref2.responseError;\n\t\n\t    if (response || responseError) {\n\t      promise = promise.then(function (_response) {\n\t        return response(_response, Object.assign({}, args[1]));\n\t      }, function (_responseError) {\n\t        return responseError(_responseError, Object.assign({}, args[1]));\n\t      });\n\t    }\n\t  });\n\t\n\t  return promise;\n\t}\n\t\n\tmodule.exports = {\n\t  register: function register(interceptor) {\n\t    interceptors.push(interceptor);\n\t    return function () {\n\t      var index = interceptors.indexOf(interceptor);\n\t      if (index >= 0) {\n\t        interceptors.splice(index, 1);\n\t      }\n\t    };\n\t  },\n\t  clear: function clear() {\n\t    interceptors = [];\n\t  }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }())))\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout() {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t})();\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch (e) {\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch (e) {\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e) {\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e) {\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while (len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) {\n\t    return [];\n\t};\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () {\n\t    return '/';\n\t};\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function () {\n\t    return 0;\n\t};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"whatwg-fetch\");\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// index.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cabe18bbe09b5dd33cbc","/*\n* Configuration for React-Native's package system\n* @providesModule whatwg-fetch\n*/\n\n\n// Uses Emscripten stategy for determining environment\nconst ENVIRONMENT_IS_REACT_NATIVE = typeof navigator === 'object' && navigator.product === 'ReactNative';\nconst ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';\nconst ENVIRONMENT_IS_WEB = typeof window === 'object';\nconst ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';\n\nif (ENVIRONMENT_IS_REACT_NATIVE) {\n  attach(global);\n} else if (ENVIRONMENT_IS_WORKER) {\n  attach(self);\n} else if (ENVIRONMENT_IS_WEB) {\n  attach(window);\n} else if (ENVIRONMENT_IS_NODE) {\n  attach(global);\n} else {\n  throw new Error('Unsupported environment for fetch-intercept');\n}\n\nfunction attach(env) {\n  // Make sure fetch is available in the given environment\n  if (!env.fetch) {\n    try {\n      require('whatwg-fetch');\n    } catch (err) {\n      throw Error('No fetch available. Unable to register fetch-intercept');\n    }\n  }\n  env.fetch = (function (fetch) {\n    return function (...args) {\n      return interceptor(fetch, ...args);\n    };\n  })(env.fetch);\n}\n\nlet interceptors = [];\n\nfunction interceptor(fetch, ...args) {\n  const reversedInterceptors = interceptors.reduce((array, interceptor) => [interceptor].concat(array), []);\n  let promise = Promise.resolve(args);\n\n  // Register request interceptors\n  reversedInterceptors.forEach(({ request, requestError }) => {\n    if (request || requestError) {\n      promise = promise.then(args => request(...args), args => requestError(...args));\n    }\n  });\n\n  // Register fetch call\n  promise = promise.then(args => fetch(...args));\n\n  // Register response interceptors\n  reversedInterceptors.forEach(({ response, responseError }) => {\n    if (response || responseError) {\n      promise = promise.then(\n        (_response) => response(_response, Object.assign({}, args[1])),\n        (_responseError) => responseError(_responseError, Object.assign({}, args[1]))\n      );\n    }\n  });\n\n  return promise;\n}\n\nmodule.exports = {\n  register: function (interceptor) {\n    interceptors.push(interceptor);\n    return () => {\n      const index = interceptors.indexOf(interceptor);\n      if (index >= 0) {\n        interceptors.splice(index, 1);\n      }\n    };\n  },\n  clear: function () {\n    interceptors = [];\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n// WEBPACK FOOTER //\n// ./~/process/browser.js","module.exports = require(\"whatwg-fetch\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"whatwg-fetch\"\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}